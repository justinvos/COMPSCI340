# COMPSCI 340 Notes


## Introduction

A computer system can be divided into four components:
* Hardware
* Operating system
* Application programs
* Users

The **hardware** provides basic computing resources for the system.

An **operating system** is a program that manages a computer's hardware and provies a basis for applications.

The **minimalist view** of operating systems includes only the minimum amount of osftware required to allow the computer to function.

The **maximalist view** of operating systems includes all the software which comes with a standard release.

The **application programs** define that ways in which these resources are used to solve users' computing problems.


The **bootstrap program** or **firmware** is the initial program that is run when the computer is powered on. It is typically stored in ROM (read-only memory) or EEPROM (electrically erasable programmable read-only memory). It then locates the operating system kernal and loads it into memory.

The **kernal** is the one program running at all times on the computer. It loads system processes and system daemons.

**Monolithic** design has all components in one, allowing them to freely interact with each other.

**Onion-layer** design seperates the components into various layers which simplifies verificaition, debugging but can be inefficient with lots of layers to traverse through.

**Modular** design only loads components when needed.

**Microkernals** includes the minimal amount of components in the operating system and all other components are user processes.

## Virtual Machines

A **Level 1** hypervisor runs at the operating system level.

A **Level 2** hypervisor runs at the application level.

**Binary translation** is the translation of code at run-time.

**Containers** look like seperate virtual machines but all share the underlying operating system.

**Paravirtualization** is the modification of the guest operating system to make it aware that it's being virtualised and make performance efficiencies.

**Application virtualization** is an application that runs on a layer which provides the resources on a different operating system.

**Programming-environment virtualization** is a virtual layer that makes source code works on various operating systems.

## Processes

A **process** is a program in execution.

A **process control block** (PCB) includes the process state, program counter, CPU registers, CPU-scheduling information and memory-management information, accounting information and I/O status information.

The **process table** stores the collection of PCBs.

A **resident table** hangs around in memory.

**Thread structures** store all of the thread-related information similar in concept to the PCB.

There are various process states:
* Creating
* Ready
* Running
* Waiting
* Suspended

There are three ways to create a process:
* Create process system call
* Copy a current process
* Create a terminal session


**Preemptive multitasking** is when something external stops the thread from its computation e.g. clock interrupt.

**Cooperative multitasking** is when a process yields its right to run or when the system stops a process when it makes a system call.


**First-come first-serve (FCFS)** scheduling queues jobs in the order they arrived.

**Round-robin** scheduling allows every job a time slice in the order they arrived and places remaining jobs at the end of the queue.

**Shortest-job first (SJF)** schedules the shortest CPU time job first.


## Real-time scheduling

**Periodic** are based on fixed time intervals.

**Sporadic** are baded on a usually unexpected external signal or change.


## Memory

### Overview

**Memory** consists of a large array of bytes, each with its own address.

Main memory and the registers built into the processor itself are the only general-purpose storage that the CPU can access directly.

**Registers** are built into the CPU and are therefore can be operated on within one clock tick.

**Main memory** requires a transaction on the memory bus, meaning it may take many clock ticks to access.

A **stall** happens when the processor is waiting on some data to complete its operation.

**Cache** is fast memory between the CPU and the main memory to reduce stalls.

**Seperate process memory space** protects the processes from each other and allows for multiple processes to be loaded.

The **base register** holds the smallest legal physcial memory address.

The **limit register** specifies the size of the range.

The **input queue** contains all the processes on disk waiting to be brought to memory for execution.

**Address binding** is where a symbolic address is converted to a relocatable address and usually at execution time, a relocatable address is converted into an absolute address.

A **logical address** or **virtual address** is an address generated by the CPU.

A **physical address** refers to the actual position in memory.

The **logical address space** is the set of all logical addresses.

The **physical address space** is the set of all physical addresses.

The **memory-management unit** (MMU) is a hardware device for mapping from logical addresses to physcial addresses. It uses a relocation register as a base so that the logical address space $[0,\text{max}]$ is mapped to the physical address space $[R + 0, R + \text{max}]$ where $R$ is the relocation register value.

With **dynamic loading**, a routine is not loaded until it is called.

**Dynamically linked libraries** are system libraries that are linked to user programs when the programs are run.

**Static linking** is where system libraries are combined by the loader into the binary program.

A **stub** is a small piece of code that indicate how to locate and link a library routine.

A process can be **swapped** temporarily out of memory into a backing store and then brought back into memory for continued execution. Swapping allows for the address space of all processes to exceed the real physical memory of the system.

The **ready queue** consists of all processes whose memory images are on the backing store or in memory and are ready to be run.

**Double buffering** is where I/O operations are transferred with operating system buffers, which is then transferred to the process buffer. This solves any issues where a process waiting for I/O is swapped out leaving the I/O no buffer to transfer to.
